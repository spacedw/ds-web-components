import { getCompatibleStyle as t, adoptStyles as i } from "./css-tag.js?module";export { CSSResult, adoptStyles, css, getCompatibleStyle, supportsAdoptingStyleSheets, unsafeCSS } from "./css-tag.js?module";
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var s;const e = window,r = e.trustedTypes,h = r ? r.emptyScript : "",o = e.reactiveElementPolyfillSupport,n = { toAttribute(t, i) {switch (i) {case Boolean:t = t ? h : null;break;case Object:case Array:t = null == t ? t : JSON.stringify(t);}return t;}, fromAttribute(t, i) {let s = t;switch (i) {case Boolean:s = null !== t;break;case Number:s = null === t ? null : Number(t);break;case Object:case Array:try {s = JSON.parse(t);} catch (t) {s = null;}}return s;} },a = (t, i) => i !== t && (i == i || t == t),l = { attribute: !0, type: String, converter: n, reflect: !1, hasChanged: a };class d extends HTMLElement {constructor() {super(), this._$Ei = new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this.u();}static addInitializer(t) {var i;this.finalize(), (null !== (i = this.h) && void 0 !== i ? i : this.h = []).push(t);}static get observedAttributes() {this.finalize();const t = [];return this.elementProperties.forEach((i, s) => {const e = this._$Ep(s, i);void 0 !== e && (this._$Ev.set(e, s), t.push(e));}), t;}static createProperty(t, i = l) {if (i.state && (i.attribute = !1), this.finalize(), this.elementProperties.set(t, i), !i.noAccessor && !this.prototype.hasOwnProperty(t)) {const s = "symbol" == typeof t ? Symbol() : "__" + t,e = this.getPropertyDescriptor(t, s, i);void 0 !== e && Object.defineProperty(this.prototype, t, e);}}static getPropertyDescriptor(t, i, s) {return { get() {return this[i];}, set(e) {const r = this[t];this[i] = e, this.requestUpdate(t, r, s);}, configurable: !0, enumerable: !0 };}static getPropertyOptions(t) {return this.elementProperties.get(t) || l;}static finalize() {if (this.hasOwnProperty("finalized")) return !1;this.finalized = !0;const t = Object.getPrototypeOf(this);if (t.finalize(), void 0 !== t.h && (this.h = [...t.h]), this.elementProperties = new Map(t.elementProperties), this._$Ev = new Map(), this.hasOwnProperty("properties")) {const t = this.properties,i = [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)];for (const s of i) this.createProperty(s, t[s]);}return this.elementStyles = this.finalizeStyles(this.styles), !0;}static finalizeStyles(i) {const s = [];if (Array.isArray(i)) {const e = new Set(i.flat(1 / 0).reverse());for (const i of e) s.unshift(t(i));} else void 0 !== i && s.push(t(i));return s;}static _$Ep(t, i) {const s = i.attribute;return !1 === s ? void 0 : "string" == typeof s ? s : "string" == typeof t ? t.toLowerCase() : void 0;}u() {var t;this._$E_ = new Promise(t => this.enableUpdating = t), this._$AL = new Map(), this._$Eg(), this.requestUpdate(), null === (t = this.constructor.h) || void 0 === t || t.forEach(t => t(this));}addController(t) {var i, s;(null !== (i = this._$ES) && void 0 !== i ? i : this._$ES = []).push(t), void 0 !== this.renderRoot && this.isConnected && (null === (s = t.hostConnected) || void 0 === s || s.call(t));}removeController(t) {var i;null === (i = this._$ES) || void 0 === i || i.splice(this._$ES.indexOf(t) >>> 0, 1);}_$Eg() {this.constructor.elementProperties.forEach((t, i) => {this.hasOwnProperty(i) && (this._$Ei.set(i, this[i]), delete this[i]);});}createRenderRoot() {var t;const s = null !== (t = this.shadowRoot) && void 0 !== t ? t : this.attachShadow(this.constructor.shadowRootOptions);return i(s, this.constructor.elementStyles), s;}connectedCallback() {var t;void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t = this._$ES) || void 0 === t || t.forEach(t => {var i;return null === (i = t.hostConnected) || void 0 === i ? void 0 : i.call(t);});}enableUpdating(t) {}disconnectedCallback() {var t;null === (t = this._$ES) || void 0 === t || t.forEach(t => {var i;return null === (i = t.hostDisconnected) || void 0 === i ? void 0 : i.call(t);});}attributeChangedCallback(t, i, s) {this._$AK(t, s);}_$EO(t, i, s = l) {var e;const r = this.constructor._$Ep(t, s);if (void 0 !== r && !0 === s.reflect) {const h = (void 0 !== (null === (e = s.converter) || void 0 === e ? void 0 : e.toAttribute) ? s.converter : n).toAttribute(i, s.type);this._$El = t, null == h ? this.removeAttribute(r) : this.setAttribute(r, h), this._$El = null;}}_$AK(t, i) {var s;const e = this.constructor,r = e._$Ev.get(t);if (void 0 !== r && this._$El !== r) {const t = e.getPropertyOptions(r),h = "function" == typeof t.converter ? { fromAttribute: t.converter } : void 0 !== (null === (s = t.converter) || void 0 === s ? void 0 : s.fromAttribute) ? t.converter : n;this._$El = r, this[r] = h.fromAttribute(i, t.type), this._$El = null;}}requestUpdate(t, i, s) {let e = !0;void 0 !== t && (((s = s || this.constructor.getPropertyOptions(t)).hasChanged || a)(this[t], i) ? (this._$AL.has(t) || this._$AL.set(t, i), !0 === s.reflect && this._$El !== t && (void 0 === this._$EC && (this._$EC = new Map()), this._$EC.set(t, s))) : e = !1), !this.isUpdatePending && e && (this._$E_ = this._$Ej());}async _$Ej() {this.isUpdatePending = !0;try {await this._$E_;} catch (t) {Promise.reject(t);}const t = this.scheduleUpdate();return null != t && (await t), !this.isUpdatePending;}scheduleUpdate() {return this.performUpdate();}performUpdate() {var t;if (!this.isUpdatePending) return;this.hasUpdated, this._$Ei && (this._$Ei.forEach((t, i) => this[i] = t), this._$Ei = void 0);let i = !1;const s = this._$AL;try {i = this.shouldUpdate(s), i ? (this.willUpdate(s), null === (t = this._$ES) || void 0 === t || t.forEach(t => {var i;return null === (i = t.hostUpdate) || void 0 === i ? void 0 : i.call(t);}), this.update(s)) : this._$Ek();} catch (t) {throw i = !1, this._$Ek(), t;}i && this._$AE(s);}willUpdate(t) {}_$AE(t) {var i;null === (i = this._$ES) || void 0 === i || i.forEach(t => {var i;return null === (i = t.hostUpdated) || void 0 === i ? void 0 : i.call(t);}), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);}_$Ek() {this._$AL = new Map(), this.isUpdatePending = !1;}get updateComplete() {return this.getUpdateComplete();}getUpdateComplete() {return this._$E_;}shouldUpdate(t) {return !0;}update(t) {void 0 !== this._$EC && (this._$EC.forEach((t, i) => this._$EO(i, this[i], t)), this._$EC = void 0), this._$Ek();}updated(t) {}firstUpdated(t) {}}d.finalized = !0, d.elementProperties = new Map(), d.elementStyles = [], d.shadowRootOptions = { mode: "open" }, null == o || o({ ReactiveElement: d }), (null !== (s = e.reactiveElementVersions) && void 0 !== s ? s : e.reactiveElementVersions = []).push("1.6.1");export { d as ReactiveElement, n as defaultConverter, a as notEqual };

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var t;const i = window,s = i.trustedTypes,e = s ? s.createPolicy("lit-html", { createHTML: t => t }) : void 0,o = "$lit$",n = `lit$${(Math.random() + "").slice(9)}$`,l = "?" + n,h = `<${l}>`,r = document,d = () => r.createComment(""),u = t => null === t || "object" != typeof t && "function" != typeof t,c = Array.isArray,v = t => c(t) || "function" == typeof (null == t ? void 0 : t[Symbol.iterator]),a = "[ \t\n\f\r]",f = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,_ = /-->/g,m = />/g,p = RegExp(`>|${a}(?:([^\\s"'>=/]+)(${a}*=${a}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`, "g"),g = /'/g,$ = /"/g,y = /^(?:script|style|textarea|title)$/i,w = t => (i, ...s) => ({ _$litType$: t, strings: i, values: s }),x = w(1),b = w(2),T = Symbol.for("lit-noChange"),A = Symbol.for("lit-nothing"),E = new WeakMap(),C = r.createTreeWalker(r, 129, null, !1),P = (t, i) => {const s = t.length - 1,l = [];let r,d = 2 === i ? "<svg>" : "",u = f;for (let i = 0; i < s; i++) {const s = t[i];let e,c,v = -1,a = 0;for (; a < s.length && (u.lastIndex = a, c = u.exec(s), null !== c);) a = u.lastIndex, u === f ? "!--" === c[1] ? u = _ : void 0 !== c[1] ? u = m : void 0 !== c[2] ? (y.test(c[2]) && (r = RegExp("</" + c[2], "g")), u = p) : void 0 !== c[3] && (u = p) : u === p ? ">" === c[0] ? (u = null != r ? r : f, v = -1) : void 0 === c[1] ? v = -2 : (v = u.lastIndex - c[2].length, e = c[1], u = void 0 === c[3] ? p : '"' === c[3] ? $ : g) : u === $ || u === g ? u = p : u === _ || u === m ? u = f : (u = p, r = void 0);const w = u === p && t[i + 1].startsWith("/>") ? " " : "";d += u === f ? s + h : v >= 0 ? (l.push(e), s.slice(0, v) + o + s.slice(v) + n + w) : s + n + (-2 === v ? (l.push(void 0), i) : w);}const c = d + (t[s] || "<?>") + (2 === i ? "</svg>" : "");if (!Array.isArray(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");return [void 0 !== e ? e.createHTML(c) : c, l];};class V {constructor({ strings: t, _$litType$: i }, e) {let h;this.parts = [];let r = 0,u = 0;const c = t.length - 1,v = this.parts,[a, f] = P(t, i);if (this.el = V.createElement(a, e), C.currentNode = this.el.content, 2 === i) {const t = this.el.content,i = t.firstChild;i.remove(), t.append(...i.childNodes);}for (; null !== (h = C.nextNode()) && v.length < c;) {if (1 === h.nodeType) {if (h.hasAttributes()) {const t = [];for (const i of h.getAttributeNames()) if (i.endsWith(o) || i.startsWith(n)) {const s = f[u++];if (t.push(i), void 0 !== s) {const t = h.getAttribute(s.toLowerCase() + o).split(n),i = /([.?@])?(.*)/.exec(s);v.push({ type: 1, index: r, name: i[2], strings: t, ctor: "." === i[1] ? k : "?" === i[1] ? I : "@" === i[1] ? L : R });} else v.push({ type: 6, index: r });}for (const i of t) h.removeAttribute(i);}if (y.test(h.tagName)) {const t = h.textContent.split(n),i = t.length - 1;if (i > 0) {h.textContent = s ? s.emptyScript : "";for (let s = 0; s < i; s++) h.append(t[s], d()), C.nextNode(), v.push({ type: 2, index: ++r });h.append(t[i], d());}}} else if (8 === h.nodeType) if (h.data === l) v.push({ type: 2, index: r });else {let t = -1;for (; -1 !== (t = h.data.indexOf(n, t + 1));) v.push({ type: 7, index: r }), t += n.length - 1;}r++;}}static createElement(t, i) {const s = r.createElement("template");return s.innerHTML = t, s;}}function N(t, i, s = t, e) {var o, n, l, h;if (i === T) return i;let r = void 0 !== e ? null === (o = s._$Co) || void 0 === o ? void 0 : o[e] : s._$Cl;const d = u(i) ? void 0 : i._$litDirective$;return (null == r ? void 0 : r.constructor) !== d && (null === (n = null == r ? void 0 : r._$AO) || void 0 === n || n.call(r, !1), void 0 === d ? r = void 0 : (r = new d(t), r._$AT(t, s, e)), void 0 !== e ? (null !== (l = (h = s)._$Co) && void 0 !== l ? l : h._$Co = [])[e] = r : s._$Cl = r), void 0 !== r && (i = N(t, r._$AS(t, i.values), r, e)), i;}class S {constructor(t, i) {this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = i;}get parentNode() {return this._$AM.parentNode;}get _$AU() {return this._$AM._$AU;}u(t) {var i;const { el: { content: s }, parts: e } = this._$AD,o = (null !== (i = null == t ? void 0 : t.creationScope) && void 0 !== i ? i : r).importNode(s, !0);C.currentNode = o;let n = C.nextNode(),l = 0,h = 0,d = e[0];for (; void 0 !== d;) {if (l === d.index) {let i;2 === d.type ? i = new M(n, n.nextSibling, this, t) : 1 === d.type ? i = new d.ctor(n, d.name, d.strings, this, t) : 6 === d.type && (i = new z(n, this, t)), this._$AV.push(i), d = e[++h];}l !== (null == d ? void 0 : d.index) && (n = C.nextNode(), l++);}return o;}v(t) {let i = 0;for (const s of this._$AV) void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[i])), i++;}}class M {constructor(t, i, s, e) {var o;this.type = 2, this._$AH = A, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$Cp = null === (o = null == e ? void 0 : e.isConnected) || void 0 === o || o;}get _$AU() {var t, i;return null !== (i = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== i ? i : this._$Cp;}get parentNode() {let t = this._$AA.parentNode;const i = this._$AM;return void 0 !== i && 11 === (null == t ? void 0 : t.nodeType) && (t = i.parentNode), t;}get startNode() {return this._$AA;}get endNode() {return this._$AB;}_$AI(t, i = this) {t = N(this, t, i), u(t) ? t === A || null == t || "" === t ? (this._$AH !== A && this._$AR(), this._$AH = A) : t !== this._$AH && t !== T && this._(t) : void 0 !== t._$litType$ ? this.g(t) : void 0 !== t.nodeType ? this.$(t) : v(t) ? this.T(t) : this._(t);}k(t) {return this._$AA.parentNode.insertBefore(t, this._$AB);}$(t) {this._$AH !== t && (this._$AR(), this._$AH = this.k(t));}_(t) {this._$AH !== A && u(this._$AH) ? this._$AA.nextSibling.data = t : this.$(r.createTextNode(t)), this._$AH = t;}g(t) {var i;const { values: s, _$litType$: e } = t,o = "number" == typeof e ? this._$AC(t) : (void 0 === e.el && (e.el = V.createElement(e.h, this.options)), e);if ((null === (i = this._$AH) || void 0 === i ? void 0 : i._$AD) === o) this._$AH.v(s);else {const t = new S(o, this),i = t.u(this.options);t.v(s), this.$(i), this._$AH = t;}}_$AC(t) {let i = E.get(t.strings);return void 0 === i && E.set(t.strings, i = new V(t)), i;}T(t) {c(this._$AH) || (this._$AH = [], this._$AR());const i = this._$AH;let s,e = 0;for (const o of t) e === i.length ? i.push(s = new M(this.k(d()), this.k(d()), this, this.options)) : s = i[e], s._$AI(o), e++;e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e);}_$AR(t = this._$AA.nextSibling, i) {var s;for (null === (s = this._$AP) || void 0 === s || s.call(this, !1, !0, i); t && t !== this._$AB;) {const i = t.nextSibling;t.remove(), t = i;}}setConnected(t) {var i;void 0 === this._$AM && (this._$Cp = t, null === (i = this._$AP) || void 0 === i || i.call(this, t));}}class R {constructor(t, i, s, e, o) {this.type = 1, this._$AH = A, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = o, s.length > 2 || "" !== s[0] || "" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = A;}get tagName() {return this.element.tagName;}get _$AU() {return this._$AM._$AU;}_$AI(t, i = this, s, e) {const o = this.strings;let n = !1;if (void 0 === o) t = N(this, t, i, 0), n = !u(t) || t !== this._$AH && t !== T, n && (this._$AH = t);else {const e = t;let l, h;for (t = o[0], l = 0; l < o.length - 1; l++) h = N(this, e[s + l], i, l), h === T && (h = this._$AH[l]), n || (n = !u(h) || h !== this._$AH[l]), h === A ? t = A : t !== A && (t += (null != h ? h : "") + o[l + 1]), this._$AH[l] = h;}n && !e && this.j(t);}j(t) {t === A ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : "");}}class k extends R {constructor() {super(...arguments), this.type = 3;}j(t) {this.element[this.name] = t === A ? void 0 : t;}}const H = s ? s.emptyScript : "";class I extends R {constructor() {super(...arguments), this.type = 4;}j(t) {t && t !== A ? this.element.setAttribute(this.name, H) : this.element.removeAttribute(this.name);}}class L extends R {constructor(t, i, s, e, o) {super(t, i, s, e, o), this.type = 5;}_$AI(t, i = this) {var s;if ((t = null !== (s = N(this, t, i, 0)) && void 0 !== s ? s : A) === T) return;const e = this._$AH,o = t === A && e !== A || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive,n = t !== A && (e === A || o);o && this.element.removeEventListener(this.name, this, e), n && this.element.addEventListener(this.name, this, t), this._$AH = t;}handleEvent(t) {var i, s;"function" == typeof this._$AH ? this._$AH.call(null !== (s = null === (i = this.options) || void 0 === i ? void 0 : i.host) && void 0 !== s ? s : this.element, t) : this._$AH.handleEvent(t);}}class z {constructor(t, i, s) {this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s;}get _$AU() {return this._$AM._$AU;}_$AI(t) {N(this, t);}}const Z = { O: o, P: n, A: l, C: 1, M: P, L: S, D: v, R: N, I: M, V: R, H: I, N: L, U: k, F: z },j = i.litHtmlPolyfillSupport;null == j || j(V, M), (null !== (t = i.litHtmlVersions) && void 0 !== t ? t : i.litHtmlVersions = []).push("2.7.1");const B = (t, i, s) => {var e, o;const n = null !== (e = null == s ? void 0 : s.renderBefore) && void 0 !== e ? e : i;let l = n._$litPart$;if (void 0 === l) {const t = null !== (o = null == s ? void 0 : s.renderBefore) && void 0 !== o ? o : null;n._$litPart$ = l = new M(i.insertBefore(d(), t), t, void 0, null != s ? s : {});}return l._$AI(t), l;};export { Z as _$LH, x as html, T as noChange, A as nothing, B as render, b as svg };
